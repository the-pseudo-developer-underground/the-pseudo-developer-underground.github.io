<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Love Tetris</title>
<style>
:root{
  --bg1:#ffe8f0; --bg2:#ffd9e3;
  --panel:#ffffff; --accent:#ff6f91; --accent-dark:#ff4c6d; --muted:#7a4a58;
  --shadow:0 10px 24px rgba(255,111,145,.35); --radius:18px;
}
*{box-sizing:border-box;margin:0;padding:0;font-family:sans-serif;}
body{background:linear-gradient(135deg,var(--bg1),var(--bg2));display:flex;flex-direction:column;align-items:center;justify-content:flex-start;min-height:100vh;color:#422c3e;}
header{margin:20px;text-align:center;}
header h1{color:#d63e50;font-size:2rem;}
header .sub{color:var(--muted);}
.container{display:flex;flex-direction:row;gap:20px;flex-wrap:wrap;justify-content:center;align-items:flex-start;}
.canvas-container{position:relative;}
canvas{background:#fff;border-radius:12px;display:block;margin:auto;max-width:100%;height:auto;}
.side{display:flex;flex-direction:column;gap:12px;}
.panel{background:#fff7fa;padding:12px;border-radius:12px;box-shadow:inset 0 0 0 1px rgba(214,62,80,.12);}
.score{font-size:1.5rem;font-weight:700;}
#next{background:#fff;border-radius:10px;display:block;margin:auto;}
.controls{display:flex;justify-content:center;gap:10px;margin-top:10px;}
.btn{padding:10px 14px;border-radius:999px;border:none;background:var(--accent);color:#fff;font-weight:700;cursor:pointer;transition:.2s;}
.btn:hover{background:var(--accent-dark);}
.overlay{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;z-index:50;}
.overlay .box{background:#fff;border-radius:16px;padding:18px;width:min(90vw,400px);text-align:center;box-shadow:var(--shadow);}
.big{font-size:1.8rem;font-weight:800;color:#d63e50;margin:6px 0 12px;}
@media (max-width:600px){
  .container{flex-direction:column;}
}
</style>
</head>
<body>
<header>
  <h1>Love Tetris ❤️</h1>
  <div class="sub">Fill the lines, not just hearts.</div>
</header>

<div class="container">
  <div class="canvas-container">
    <canvas id="board" width="300" height="600"></canvas>
  </div>
  <div class="side">
    <div class="panel">
      <h3>Score</h3>
      <div class="score" id="score">0</div>
    </div>
    <div class="panel">
      <h3>Next</h3>
      <canvas id="next" width="120" height="120"></canvas>
    </div>
    <button id="startBtn" class="btn">Start</button>
    <button id="pauseBtn" class="btn">Pause</button>
    <button id="restartBtn" class="btn">Restart</button>
  </div>
</div>

<div class="overlay" id="overlay">
  <div class="box">
    <div id="overlayTitle" class="big">You filled my heart ❤️</div>
    <p id="overlayMsg">Final score: <span id="finalScore">0</span></p>
    <button id="overlayBtn" class="btn">Play again</button>
  </div>
</div>

<audio id="bgm" loop></audio>

<script>
/* ---------- THEME ---------- */
const COLORS = {I:'#ff6f91',J:'#a06cd5',L:'#ff8fab',O:'#ffd6a5',S:'#caffbf',T:'#b388eb',Z:'#ffadad'};
const GHOST = 'rgba(0,0,0,.12)';

/* ---------- GAME CONSTANTS ---------- */
const COLS=10,ROWS=20,SIZE=30,DROP_START_MS=800,DROP_ACCEL_SOFT=40;
const SCORE_SINGLE=100,SCORE_DOUBLE=300,SCORE_TRIPLE=500,SCORE_TETRIS=800,SCORE_SOFT=1,SCORE_HARD_PER_ROW=2;

/* ---------- CANVAS ---------- */
const boardCV=document.getElementById('board'),bctx=boardCV.getContext('2d');
const nextCV=document.getElementById('next'),nctx=nextCV.getContext('2d');
const scoreEl=document.getElementById('score'),startBtn=document.getElementById('startBtn');
const pauseBtn=document.getElementById('pauseBtn'),restartBtn=document.getElementById('restartBtn');
const overlay=document.getElementById('overlay'),overlayTitle=document.getElementById('overlayTitle');
const overlayMsg=document.getElementById('overlayMsg'),overlayBtn=document.getElementById('overlayBtn');
const bgm=document.getElementById('bgm');

/* ---------- MUSIC ---------- */
const SONGS=[...Array(9)].map((_,i)=>`../music/${i+1}.mp3`);
function playRandomSong(){
  const song = SONGS[Math.floor(Math.random()*SONGS.length)];
  bgm.src=song; bgm.play().catch(()=>{});
}
bgm.addEventListener('ended',playRandomSong);

/* ---------- BOARD ---------- */
const emptyRow=()=>Array(COLS).fill(null);
let grid=Array(ROWS).fill(0).map(emptyRow);
let score=0;

/* ---------- SHAPES ---------- */
const SHAPES={I:[[1,1,1,1]],J:[[1,0,0],[1,1,1]],L:[[0,0,1],[1,1,1]],O:[[1,1],[1,1]],S:[[0,1,1],[1,1,0]],T:[[0,1,0],[1,1,1]],Z:[[1,1,0],[0,1,1]]};
const TYPES=Object.keys(SHAPES);
function* bagGenerator(){while(true){const bag=TYPES.slice();for(let i=bag.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[bag[i],bag[j]]=[bag[j],bag[i]]}for(const t of bag)yield t;}}
const bag=bagGenerator();
function createPiece(type){const shape=SHAPES[type].map(r=>r.slice());return {type,shape,x:Math.floor((COLS-shape[0].length)/2),y:-shape.length,color:COLORS[type]};}
let current=null,next=createPiece(bag.next().value);

/* ---------- DRAWING ---------- */
function drawCell(ctx,x,y,color){ctx.fillStyle=color;ctx.fillRect(x*SIZE,y*SIZE,SIZE,SIZE);ctx.strokeStyle='rgba(0,0,0,.06)';ctx.strokeRect(x*SIZE,y*SIZE,SIZE,SIZE);}
function drawBoard(){bctx.clearRect(0,0,boardCV.width,boardCV.height);for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){const cell=grid[r][c];if(cell)drawCell(bctx,c,r,cell);}if(current){const ghostY=dropDistance();for(let r=0;r<current.shape.length;r++)for(let c=0;c<current.shape[r].length;c++){if(current.shape[r][c])drawCell(bctx,current.x+c,current.y+r+ghostY,GHOST);}for(let r=0;r<current.shape.length;r++)for(let c=0;c<current.shape[r].length;c++){if(current.shape[r][c])drawCell(bctx,current.x+c,current.y+r,current.color);}}}
function drawNext(){nctx.clearRect(0,0,nextCV.width,nextCV.height);const s=next.shape;const w=s[0].length,h=s.length;const offsetX=Math.floor((4-w)/2);const offsetY=Math.floor((4-h)/2);const cell=24;for(let r=0;r<h;r++)for(let c=0;c<w;c++)if(s[r][c]){nctx.fillStyle=next.color;nctx.fillRect((c+offsetX)*cell,(r+offsetY)*cell,cell,cell);nctx.strokeStyle='rgba(0,0,0,.08)';nctx.strokeRect((c+offsetX)*cell,(r+offsetY)*cell,cell,cell);}}

function valid(posX,posY,shape){for(let r=0;r<shape.length;r++)for(let c=0;c<shape[r].length;c++){if(!shape[r][c])continue;const x=posX+c,y=posY+r;if(x<0||x>=COLS||y>=ROWS)return false;if(y>=0&&grid[y][x])return false;}return true;}
function rotate(shape){const h=shape.length,w=shape[0].length,res=Array(w).fill(0).map(()=>Array(h).fill(0));for(let r=0;r<h;r++)for(let c=0;c<w;c++)res[c][h-1-r]=shape[r][c];return res;}
function lockPiece(){for(let r=0;r<current.shape.length;r++)for(let c=0;c<current.shape[r].length;c++){if(current.shape[r][c]){const x=current.x+c,y=current.y+r;if(y<0){endGame();return;}grid[y][x]=current.color;}}clearLines();spawn();}
function clearLines(){let cleared=0;for(let r=ROWS-1;r>=0;r--){if(grid[r].every(Boolean)){grid.splice(r,1);grid.unshift(emptyRow());cleared++;r++;}}if(cleared){const add=cleared===1?SCORE_SINGLE:cleared===2?SCORE_DOUBLE:cleared===3?SCORE_TRIPLE:SCORE_TETRIS;updateScore(add);}}
function updateScore(add=0,reset=false){if(reset)score=0;else score+=add;scoreEl.textContent=score;overlayMsg.innerHTML=`Final score: <span id="finalScore">${score}</span>`;}
function spawn(){current=next;next=createPiece(bag.next().value);drawNext();}
function dropDistance(){let d=0;while(valid(current.x,current.y+d+1,current.shape))d++;return d;}
function moveDown(){if(valid(current.x,current.y+1,current.shape))current.y++;else lockPiece();}
function hardDrop(){const dist=dropDistance();current.y+=dist;updateScore(dist*SCORE_HARD_PER_ROW);lockPiece();}

/* ---------- GAME LOOP ---------- */
let last=0,dropCounter=0,dropInterval=DROP_START_MS,softDrop=false,playing=false,paused=false,gameOver=false;
function loop(time=0){if(!playing||paused)return;const delta=time-last;last=time;dropCounter+=delta;const interval=softDrop?DROP_ACCEL_SOFT:dropInterval;if(dropCounter>interval){moveDown();dropCounter=0;}drawBoard();requestAnimationFrame(loop);}
function startGame(){resetBoard();spawn();drawNext();drawBoard();playing=true;paused=false;gameOver=false;overlay.style.display='none';last=performance.now();dropCounter=0;playRandomSong();requestAnimationFrame(loop);}
function endGame(){playing=false;gameOver=true;overlayTitle.textContent='You filled my heart ❤️';overlay.style.display='flex';bgm.pause();}
function togglePause(){if(!playing||gameOver)return;paused=!paused;if(!paused){last=performance.now();dropCounter=0;requestAnimationFrame(loop);playRandomSong();}else{bgm.pause();}}
function resetBoard(){grid=Array(ROWS).fill(0).map(emptyRow);score=0;updateScore(0,true);drawBoard();}

/* ---------- INPUT ---------- */
document.addEventListener('keydown',e=>{if(!playing||paused){if(e.key.toLowerCase()==='p')togglePause();return;}if(e.key==='ArrowLeft'){if(valid(current.x-1,current.y,current.shape))current.x--;}else if(e.key==='ArrowRight'){if(valid(current.x+1,current.y,current.shape))current.x++;}else if(e.key==='ArrowDown'){softDrop=true;updateScore(SCORE_SOFT);}else if(e.key==='ArrowUp'){const rotated=rotate(current.shape);if(valid(current.x,current.y,rotated))current.shape=rotated;else if(valid(current.x-1,current.y,rotated)){current.x--;current.shape=rotated;}else if(valid(current.x+1,current.y,rotated)){current.x++;current.shape=rotated;}}else if(e.code==='Space'){e.preventDefault();hardDrop();}else if(e.key.toLowerCase()==='p'){togglePause();}drawBoard();});
document.addEventListener('keyup',e=>{if(e.key==='ArrowDown')softDrop=false;});

/* ---------- BUTTONS ---------- */
startBtn.addEventListener('click',startGame);
pauseBtn.addEventListener('click',togglePause);
restartBtn.addEventListener('click',startGame);
overlayBtn.addEventListener('click',startGame);

/* ---------- MOBILE SWIPE ---------- */
let touchStartX=0,touchStartY=0,touchEndX=0,touchEndY=0;
boardCV.addEventListener('touchstart',e=>{const t=e.touches[0];touchStartX=t.clientX;touchStartY=t.clientY;});
boardCV.addEventListener('touchend',e=>{const t=e.changedTouches[0];touchEndX=t.clientX;touchEndY=t.clientY;handleSwipe();});
function handleSwipe(){
  const dx=touchEndX-touchStartX,dy=touchEndY-touchStartY;
  if(Math.abs(dx)>Math.abs(dy)){
    if(dx>30 && valid(current.x+1,current.y,current.shape)) current.x++; // swipe right
    else if(dx<-30 && valid(current.x-1,current.y,current.shape)) current.x--; // swipe left
  } else {
    if(dy>30) moveDown(); // swipe down
    else if(dy<-30){ // swipe up = rotate
        const rotated = rotate(current.shape);
        if(valid(current.x,current.y,rotated)) current.shape=rotated;
        else if(valid(current.x-1,current.y,rotated)) {current.x--; current.shape=rotated;}
        else if(valid(current.x+1,current.y,rotated)) {current.x++; current.shape=rotated;}
    }
  }
  drawBoard();
}

/* ---------- RESPONSIVE ---------- */
function resizeCanvas(){
    const width = Math.min(window.innerWidth*0.9, 300);
    boardCV.width = width;
    boardCV.height = width*2;
    drawBoard();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();
</script>
</body>
</html>
